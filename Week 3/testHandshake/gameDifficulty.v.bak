module gameDifficulty(
	input hard,
	input med,
	input easy,
	input clock,
	input resetn,
	output reg playHard, playMedium, playEasy, externalReset
	);
	
	reg [1:0] currentState, nextState;
	
	localparam IDLE = 2'd0,
				HARD = 2'd1,
				MEDIUM = 2'd2,
				EASY = 2'd3,
				GAME_OVER = 2'd4;
	
	always @ (*)
	begin: state_table
		case(currentState)
			IDLE: begin	
				nextState = (hard & ~med & ~easy) ? HARD : IDLE;
				nextState = (~hard & med & ~easy) ? MED : IDLE;
				nextState = (~hard & ~med & easy) ? EASY : IDLE;
			end
			
			HARD: nextState =  hard ? HARD : GAME_OVER;
			
			MED: nextState =  med ? MED : GAME_OVER;
			
			EASY: nextState =  easy ? EASY : GAME_OVER;
			
			GAME_OVER: nextState = IDLE;
			
			default : nextState = IDLE;
		endcase
	end
	
	always @ (*)
	begin: send_game_difficulty_info
		playHard = 1'd0;
		playMedium = 1'd0;
		playEasy = 1'd0;
		externalReset = 1'd0;
		
		case (currentState)
			IDLE: begin
				playHard = 1'd0;
				playMedium = 1'd0;
				playEasy = 1'd0;
				externalReset = 1'd0;
			end
			
			HARD: playHard = 1'd1;
			
			MED: playMedium = 1'd1;
			
			EASY: playEasy = 1'd1;
			
			GAME_OVER: begin
				externalReset = 1'd1;
				playHard = 1'd0;
				playMedium = 1'd0;
				playEasy = 1'd0;
			end
			
		endcase
	end
	
	always @ (posedge clock) 
	begin
		if(!resetn)
			currentState <= IDLE;
		else
			currentState <= nextState;
	end
	
endmodule
